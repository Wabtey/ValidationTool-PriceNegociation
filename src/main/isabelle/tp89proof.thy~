theory tp89proof
imports Main table "~~/src/HOL/Library/Code_Target_Nat" 
begin

(* 
  quickcheck [size=7,tester=narrowing,timeout=300]
  nitpick [timeout=300]

  Si on veut du temps supplémentaire avec sledgehammer:
  sledgehammer [provers=e cvc4 spass remote_vampire z3,timeout=300]

  Pour guider l'utilisation de théorèmes particuliers: 
  sledgehammer [provers=e cvc4 spass remote_vampire z3,timeout=300] (add: th1 th2 ...)
*)


(* 
  Très important!
  ---------------

  Il faut vous assurer en même temps que vous développez votre code et vos preuves
  que le 'export_code' réussi.

  En particulier, à partir du moment où on utilise "~~/src/HOL/Library/Code_Target_Nat" pour 
  exporter les nat vers des nat Scala, on perd la possibilité de faire du pattern matching 
  sur ces nat. Par exemple une fonction avec des équations de la forme:

  f 0 = ...
  f (Suc x) = ...

 Ne sera plus exportable. Ca ne sert donc à rien de tenter de la prouver, car vous ne pourrez 
 pas l'exporter telle quelle.
*)

(* (client, dealer, transactionNumber) *)
type_synonym transid= "nat*nat*nat"

type_synonym price= "nat" (* "nat*nat" for float ? *)
type_synonym sellerPrice= "price"
type_synonym buyerPrice= "price"

type_synonym potentialSellerPrice= "sellerPrice option"
type_synonym potentialBuyerPrice= "buyerPrice option"

datatype message= 
  Pay transid buyerPrice  
| Ack transid sellerPrice
| Cancel transid

(*
  InProgress (potential seller's price) (potential buyer's price) |
  Validated (agreed price) |
  Canceled
*)
datatype state=
  InProgress potentialSellerPrice potentialBuyerPrice
| Validated price
| Canceled

type_synonym ligneBdd= "state"

(* Le type d'un element de la Bdd: l'identifiant de transaction associée à une ligne de la Bdd *)
type_synonym transBdd= "(transid , ligneBdd) table"

(*
  Le type des transactions validées.
  - transid: transaction's id
  - nat: transaction's total
*)
type_synonym transaction= "transid * price"

(*
  treatPay is only effective for a InProgress transaction and not initialized tid.

  - case \<degree>1: There were no transaction for the tid yet;
  - case \<degree>2: `InProgress None None` should never happen in our implementation but just in case;
  - case \<degree>3: The buyer has set the price, but not the seller. We update the buyerPrice if necessary;
  - case \<degree>4: The buyer has not yet set the price, but the seller has.
      if newPrice and sellerPrice are = 0, it can create a `InProgress Some 0 Some 0`
      but no softlock, as the buyer can set a higher price to validate it;
  - case \<degree>5: The buyer and seller has already set their price.
      We don't need to verify if newPrice > 0 to validate or not,
      because newPrice > oldBuyerPrice::nat so even if oldBuyerPrice = 0, newPrice won't be null;
  - case \<degree>6: The transaction has been locally canceled or validated.
*)
fun treatPay::"transid \<Rightarrow> price \<Rightarrow> transBdd \<Rightarrow> transBdd" where
  "treatPay tid newPrice tbdd = (
    case assoc tid tbdd of
        None \<Rightarrow> modify tid (InProgress None (Some newPrice)) tbdd

      | Some (InProgress None None) \<Rightarrow> modify tid (InProgress None (Some newPrice)) tbdd
      | Some (InProgress None (Some oldBuyerPrice)) \<Rightarrow>
          if newPrice > oldBuyerPrice then
            modify tid (InProgress None (Some newPrice)) tbdd
          else tbdd
      | Some (InProgress (Some sellerPrice) None) \<Rightarrow>
          if newPrice \<ge> sellerPrice \<and> newPrice > 0 then
            modify tid (Validated newPrice) tbdd
          else
            modify tid (InProgress (Some sellerPrice) (Some newPrice)) tbdd
      | Some (InProgress (Some sellerPrice) (Some oldBuyerPrice)) \<Rightarrow>
          if newPrice > oldBuyerPrice then
            if newPrice \<ge> sellerPrice then
              modify tid (Validated newPrice) tbdd
            else
              modify tid (InProgress (Some sellerPrice) (Some newPrice)) tbdd
          else tbdd

      | Some _ \<Rightarrow> tbdd
  )"

(*
  treatAck

  - case \<degree>1: There were no transaction for the tid yet;
  - case \<degree>2: Just for security as our implementation can't create a InProgress None None;
  - case \<degree>3: The seller has set the price, but not the buyer. We update the sellerPrice if necessary;
  - case \<degree>4: The seller has not yet set the price, but the buyer has.
      If newPrice and buyerPrice are = 0 then it will create a ligneBdd:
        (tid, InProgress Some 0 Some 0)
      This is not a softlock of the transaction, as the buyer can set a higher price to validate it;
  - case \<degree>5: The seller and buyer has already set their price.
      Same situation as case\<degree>4 if oldSellerPrice > 0, no softlock;
  - case \<degree>6: The transaction has been locally canceled or validated.
*)
fun treatAck::"transid \<Rightarrow> price \<Rightarrow> transBdd \<Rightarrow> transBdd" where
  "treatAck tid newPrice tbdd = (
    case assoc tid tbdd of
        None \<Rightarrow> modify tid (InProgress (Some newPrice) None) tbdd

      | Some (InProgress None None) \<Rightarrow> modify tid (InProgress (Some newPrice) None) tbdd
      | Some (InProgress (Some oldSellerPrice) None) \<Rightarrow>
          if newPrice < oldSellerPrice then
              modify tid (InProgress (Some newPrice) None) tbdd
          else tbdd
      | Some (InProgress None (Some buyerPrice)) \<Rightarrow>
          if newPrice \<le> buyerPrice \<and> buyerPrice > 0 then
            modify tid (Validated buyerPrice) tbdd
          else
            modify tid (InProgress (Some newPrice) (Some buyerPrice)) tbdd         
      | Some (InProgress (Some oldSellerPrice) (Some buyerPrice)) \<Rightarrow>
          if newPrice < oldSellerPrice then
            if newPrice \<le> buyerPrice \<and> buyerPrice > 0 then
              modify tid (Validated buyerPrice) tbdd
            else
              modify tid (InProgress (Some newPrice) (Some buyerPrice)) tbdd
          else tbdd

      | Some _ \<Rightarrow> tbdd
  )"

fun traiterMessage::"message \<Rightarrow> transBdd \<Rightarrow> transBdd" where
  "traiterMessage (Cancel tid) tbdd = modify tid Canceled tbdd" |
  "traiterMessage (Pay tid price) tbdd = treatPay tid price tbdd" |
  "traiterMessage (Ack tid price) tbdd = treatAck tid price tbdd"

fun keyPresent::"'a \<Rightarrow> ('a * 'b) list \<Rightarrow> bool" where
  "keyPresent _ [] = False" |
  "keyPresent e ((key, _) # rem) = (e = key \<or> keyPresent e rem)"

fun export::"transBdd \<Rightarrow> transaction list" where
  "export [] = []" |
  "export ((tid, state) # bdd) = (
    let validated_transactions = export bdd in
    case state of
        Validated price \<Rightarrow> 
          if price = 0 \<or> keyPresent tid validated_transactions then
            validated_transactions
          else
            (tid, price) # validated_transactions
      | _ \<Rightarrow> export bdd
  )"

(* Lemmes intermédiaires conseillés *)

(* Lemme 1*)
(* Soit m un message d'identifiant tid2. Si tid\<noteq>tid2 alors la valeur associée à tid dans la
   base de donnée ne sera pas modifiée par le traitement du message m.

   Au préalable, il est conseillé de faire des lemmes intermédiaires pour les 3 types de messages à traiter: Pay, Ack, Cancel et
   de les utiliser pour prouver celui-ci *)
lemma preciseModificationPay:
  "tid1\<noteq>tid2 \<longrightarrow> assoc tid1 tbdd = assoc tid1 (traiterMessage (Pay tid2 price) tbdd)"
  (*
  quickcheck [size=7,tester=narrowing,timeout=300]
  nitpick [timeout=300]
  *)
  apply (induct tbdd)
  apply simp
  sledgehammer
  sorry

lemma preciseModificationAck:
  "tid1\<noteq>tid2 \<longrightarrow> assoc tid1 tbdd = assoc tid1 (traiterMessage (Ack tid2 price) tbdd)"
  quickcheck [size=7,tester=narrowing,timeout=300]
  nitpick [timeout=300]
  apply (induct tbdd)
  apply simp
  sledgehammer
  sorry


lemma preciseModificationCancel:
  "tid1\<noteq>tid2 \<longrightarrow> assoc tid1 tbdd = assoc tid1 (traiterMessage (Cancel tid2) tbdd)"
  (*
  quickcheck [size=7,tester=narrowing,timeout=300]
  nitpick [timeout=300]
  *)
  sorry

lemma preciseModification:
  "preciseModificationPay \<and> preciseModificationAck \<and> preciseModificationCancel"
  apply auto
  sorry

(* Lemme 2 *)
(* Quelque soit la bdd quand on traite un message (Cancel tid), on obtient une nouvelle 
   bdd dans laquelle tid est associé à un statut annulé, et des prix client et marchand 
   indéfinis *)
lemma cancelIsEffective: (* aka cancelCultureIsReal in negociation *)
  "assoc tid (traiterMessage (Cancel tid) tbdd) = Some Canceled"
  apply (induct tbdd)
  apply simp
  by (simp add: mapModificationProperty)
 
(* On traite les messages en commencant par la fin de la liste. On voit la liste comme une file. 
   Coherent avec ce qui se passe dans l'IHM. Cela simplifie grandement les preuves! *)

fun traiterMessageList:: "message list \<Rightarrow> transBdd"
where
"traiterMessageList [] = []" |
"traiterMessageList (m#r)= (traiterMessage m (traiterMessageList r))"


(* Définir une fonction validOne déterminant si une ligne de la Bdd est valide.
   Une bdd tbdd sera valide si (forAll validOne tbdd) est vraie *)

(* FIXME: Valid != Validated *)

(* abbreviation validOne::"(transid * ligneBdd) \<Rightarrow> bool" where "validOne (tid, state) \<equiv> state = (Validated _)" *)
fun validOne::"(transid * ligneBdd) \<Rightarrow> bool" where
  "validOne (_, Validated price) = (price > 0)" |
  "validOne _ = True"

abbreviation valid::"transBdd \<Rightarrow> bool" where "valid tbdd \<equiv> forAll (validOne) tbdd"

(* Lemme 3 *)
(* Si une bdd est valide, alors quelque soit la ligne obtenue par la fonction assoc, celle-ci est valide *)
lemma validLine:
  "valid transBdd \<longrightarrow> (assoc tid transBdd = Some state \<longrightarrow> validOne (tid,state))"
  apply (induct transBdd)
  apply simp
  by (metis (full_types) assoc.simps(2) forAll.simps(2) old.prod.exhaust table.option.inject)

(* Lemme 4 *)
(* Si une bdd est valide, pour toute ligne associée à un tid, si le statut est Validated, 
   cela signifie que le prix marchand est supérieur ou égal au prix client *)

(* In my state struct impl, I do not store buyer's price nor seller's price... *)
lemma validationPriceIsFromAnAgreement:
  "valid transBdd \<longrightarrow> (assoc tid transBdd = Some (Validated price) \<longrightarrow> True)"
  by auto

(* Lemme 5 *)
(* Si une bdd est valide, elle restera valide pour toutes les modifications (valides) opérées. *)
(* Par exemple:
  Si une bdd est valide et que l'on modifie la ligne associée à tid par une nouvelle ligne 
  correcte alors la nouvelle bdd est valide également.

  Définir et prouver tous les cas possibles de modification dans des lemmes distincts.
*)
lemma validUntilDeath: "valid transBdd \<longrightarrow> True"
  by auto

(* Lemme 6 *)
(* Si une bdd est valide alors pour toute ligne associée à tid, si le statut est Validated alors p1 et p2 ne peuvent être indéfinis *)
lemma "valid transBdd \<longrightarrow> (assoc tid transBdd = Some (Validated price) \<longrightarrow> price \<ge> 0)"
  by auto

(* Lemme 7 *)
(* Dans une bdd valide alors pour toute ligne associée à tid, avec des prix client et marchand définis, si le prix client est supérieur
   ou égal au prix du marchand alors le statut de la ligne est Validated *)

(* NOTE: In my implementation, I differenciate the two states so... *)
lemma finalPrice:
  "valid transBdd \<longrightarrow> (
    assoc tid transBdd = Some (InProgress sellerPrice buyerPrice) \<longrightarrow>
      (buyerPrice \<ge> sellerPrice \<longrightarrow> assoc tid transBdd = Some(Validated buyerPrice))
  )"
  oops

(* Lemme 8 *)
(* Dans une bdd valide, pour toute ligne associée à tid, si le statut est Partial, alors le prix du client ou du marchand est défini. *)

(* TODO: Quel statut ?! *)
lemma
  "valid transBdd \<longrightarrow> (
    assoc tid transBdd = Some state \<longrightarrow> True
  )"
  oops

(* Lemme 9 *)
(* Si une bdd est valide, traiter un message Pay sur cette bdd rendra une bdd valide *)

(* Lemme 10 *)
(* Si une bdd est valide, traiter un message Ack sur cette bdd rendra une bdd valide *)

(* Lemme 11 *)
(* Si une bdd est valide, traiter un message Cancel sur cette bdd rendra une bdd valide *)

(* Lemme 12 *)
(* Si une bdd est valide, traiter tout message sur cette bdd rendra une bdd valide *)

(* Lemme 13 *)
(* traiterMessageList ne construit que des bdds valides *)
(*
lemma traiterMessageListReturnsValid:
  "valid (traiterMessageList list bdd)"
  oops
*)


(* ---- Prop 1: Toutes les transactions validées ont un montant strictement supérieur à 0. *)

(* Lemme intermédiaire: Lemme 14 *)
(* A partir de toute bdd valide, export contruit une liste de couples (tid,p) tel que
   p est strictement positif *)
(*
lemma lemma14: "valid tbdd \<longrightarrow> forAll validOne (export tbdd)"
  oops
*)

lemma totalPositive: "List.member (export tbdd) transaction \<longrightarrow> (snd transaction) > 0"
  sorry
(* ---- Prop2: 
   Dans la liste de transactions validées, tout triplet {\tt (c,m,i)} (où
  {\tt c} est un numéro de client, {\tt m} est un numéro de marchand et {\tt i}
  un numéro de transaction) n'apparaît qu'une seule fois.
*)

(* Lemmes intermédiaires *)

(* Lemme 15 *)
(* Si une bdd a des clés uniques, traiter un message Pay rend une bdd avec des clés uniques *)

(* Lemme 16 *)
(* Si une bdd a des clés uniques, traiter un message Ack rend une bdd avec des clés uniques *)

(* Lemme 17 *)
(* Si une bdd a des clés uniques, traiter un message Pay/Ack/Cancel rend une bdd avec des clés uniques *)

(* Lemme 18 *)
(* traiterMessageList rend une bdd avec des clés uniques *)

(* Lemme 19 *)
(* Les transactions ne figurant pas dans la bdd, ne figurent pas dans l'export *)

(* Lemme 20 *)
(* Si les clés sont unique dans une bdd, elles le seront dans l'export *)

(* Définir prop2 *)

lemma transidUnique: "\<forall> trans1 trans2::transaction. List.member (export tbdd) trans1 \<and> List.member (export tbdd) trans2\<longrightarrow> fst trans1 = fst trans2 \<longrightarrow> trans1 = trans2"
  oops
(* Prop 3 *)
(* Toute transaction (même validée) peut être annulée. *)
(* Prop 4*)
(* Toute transaction annulée l'est définitivement: un message {\tt (Cancel
    (c,m,i))} rend impossible  la validation d'une transaction de numéro {\tt
    i} entre un marchand {\tt m} et un client {\tt c}.*)

(* On fait les deux en une seule propriété *)

(*
lemma cancelIsAlwaysPossible:
  "assoc tid (traiterMessage (Cancel tid) bdd) = Some (Canceled)"
  using cancelIsEffective by blast
*)

(* Lemme 21 *)
(* Dans une bdd si le statut d'une transaction est Cancelled, celui-ci reste Cancelled quelque soit le message traité *)
lemma canceledForEver:
  "assoc tid bdd = Some Canceled \<longrightarrow> assoc tid (traiterMessage msg bdd) = Some Canceled"
  apply (induct bdd)
  apply simp
  sorry

(* Lemme 22 *)
(* Si un message (Cancel tid) apparaît dans une liste de message et que l'on construit
   une bdd par traitement de toute cette liste de message, alors dans cette bdd, la ligne 
   associée à la transation tid aura un statut Cancelled et les prix seront indéfinis *)
lemma cancelIsPrior:
  "List.member msgList (Cancel tid) \<longrightarrow> assoc tid (traiterMessageList msgList) = Some Canceled"
  quickcheck [size=7,tester=narrowing,timeout=300]
  nitpick [timeout=300]  
  sorry

(* Lemme 23 *)
(* Dans une bdd si une transaction est annulée, celle-ci n'apparaîtra pas dans l'export *)
lemma noCancelInExport:
  "assoc tid bdd = Some Canceled \<longrightarrow> \<not>List.member (export bdd) tid"

(* Définir prop 3 et 4 *)


(* Prop 5:
Si un message {\tt Pay} et un message {\tt Ack}, tels que le montant
  proposé par le {\tt Pay} est strictement supérieur à 0, supérieur ou égal au
  montant proposé par le message {\tt Ack} et non annulée, ont été envoyés alors la transaction figure
  dans la liste des transactions validées.
*)

(* Lemme 24 *)
(* Si les clés sont uniques dans une bdd, une transition aura le statut Validated si et seulement si 
   elle figure dans l'export *)

(* Lemme 25 *)
(* Si le message (Cancel tid) n'apparaît PAS dans une liste de message et que l'on construit
   une bdd par traitement de toute cette liste de message, la ligne 
   associée à la transation tid dans la bdd ne pourra avoir le statut Cancelled *)

(* Lemme 26 *)
(* Si une liste de message lmess contient un message de la forme (Pay tid mc) et ne contient pas de (Cancel tid) alors 
   alors il existe une ligne associée à tid dans la bdd obtenue par traitement de lmess et le prix client est défini. *)

(* Lemme 27 *)
(* Si une liste de message lmess contient un message de la forme (Ack tid mc) et ne contient pas de (Cancel tid) alors 
   alors il existe une ligne associée à tid dans la bdd obtenue par traitement de lmess et le prix marchand est défini. *)


(* Lemme 28 *)
lemma PricePayMessage: "(mc > 0 \<and>
  (forAll validOne tbdd) \<and> ((assoc tid tbdd) = (Some (p3,p4,s2))) \<and> s2\<noteq>Validated 
    \<and> ((assoc tid (traiterMessage (Pay tid mc) tbdd)) = (Some ((Mynat p1),p2,s))))
      \<longrightarrow> p1\<ge>mc"
sorry

(* Lemme 29 *)
lemma PricePayMessage2: "(mc > 0 \<and>
  (forAll validOne tbdd) \<and> ((assoc tid (traiterMessage (Pay tid mc) tbdd)) = (Some ((Mynat p1),p2,s))) 
  \<and> s\<noteq>Validated) \<longrightarrow> p1\<ge>mc"
sorry

(* Lemme 30 *)
(* Un message Ack ne peut changer le prix client dans une base valide *)

(* Lemme 31 *)
(* Un message Pay ne peut changer le prix marchand dans une base valide*)

(* Lemme 31 bis *)
(* Soit une tbdd valide, si dans cette base le prix client est mc pour un tid donné, alors
   Traiter un message Pay sur le même tid avec un prix inférieur ou égal à mc, ne change
   pas la base de données *)

(* Lemme 32 *)
(* Soit une bdd obtenue par traitement d'une liste de message contenant un message (Pay tid mc)
   Si cette bdd contient une ligne pour tid, que le prix client est défini et vaut p1, alors p1 est supérieur
   ou égal à mc. 
 *)

(* Lemme 33 *)
lemma PriceAckMessage: "((forAll validOne tbdd) \<and> ((assoc tid tbdd) = (Some (p3,p4,s2))) \<and> s2\<noteq>Validated 
    \<and> ((assoc tid (traiterMessage (Ack tid mm) tbdd)) = (Some (p1,(Mynat p2),s))))
      \<longrightarrow> p2\<le>mm"
sorry

(* Lemme 34 *)
lemma PriceAckMessage2: "((forAll validOne tbdd) \<and> ((assoc tid (traiterMessage (Ack tid mm) tbdd)) = (Some (p1,(Mynat p2),s))) \<and> s\<noteq>Validated)
  \<longrightarrow> p2\<le>mm"
sorry


(* Lemme 35 *)
(* Soit une bdd obtenue par traitement d'une liste de message contenant un message (Ack tid mm)
   Si cette bdd contient une ligne pour tid, que le prix marchand est défini et vaut p2, alors p2 est inférieur
   ou égal à mm. 
 *)

(* Lemme 36 *)
(* Si une liste de message lmess contient un (Pay tid mc) et (Ack tid mm) avec mc supérieur ou égal 
   à mm (et mc supérieur à 0) et pas de (Cancel tid) alors il existe une ligne associée 
   à tid dans la bdd générée en traitant lmess. Dans cette ligne le statut est Validated et les prix 
   client et marchand sont définis. *)


(* Définir Prop5 *)


(* Prop 6:
Toute transaction figurant dans la liste des transactions validées l'a été
  par un message {\tt Pay} et un message {\tt Ack} tels que le montant proposé
  par le {\tt Pay} est supérieur ou égal au montant proposé par le message {\tt
    Ack}.  *)

(* Lemme 37 *)
(*Soit une bdd produite par traitement d'une liste de messages lmess. 
  Dans la bdd tout prix client mc associé à tid, vient d'un message (Pay tid mc) figurant dans lmess *)

(* Lemme 38 *)
(*Soit une bdd produite par traitement d'une liste de messages lmess. 
  Dans la bdd tout prix marchand mm associé à tid, vient d'un message (Ack tid mm) figurant dans lmess *)

(* Lemme 39 *)
(* Si une transaction figure dans le export alors elle a une ligne dans la bdd avec un statut Validated *)

(* Définir Prop6 *)


(* Prop 7 *)
(*
  Si un client (resp. marchand) a proposé un montant {\tt am} pour une
  transaction, tout montant {\tt am'} inférieur (resp. supérieur) proposé par la 
  suite est ignoré par l'agent de validation.
*)

(* Lemme 40 *)
(* Dans une bdd si une transaction est validée, elle le reste quelque soit le message de type Pay que l'on traite et ses
   valeurs de prix marchand et client sont conservées. *)

(* Lemme 41 *)
(* Dans une bdd si une transaction est validée, elle le reste quelque soit le message de type Ack que l'on traite et ses
   valeurs de prix marchand et client sont conservées. *)


(* Prop7 pour un message client *)
(* Soit tbdd une bdd obtenue après traitement d'une liste de messages lmess et mc1 et mc2 deux prix tels que mc1>0 et mc2>mc1.
   Soit lmess une liste de messages contenant (Pay tid mc2) et ne contenant pas (Pay tid mc1). Si l'on traite (Pay tid mc1) 
   sur tbdd, ça ne changera pas la ligne associée à tid dans la bdd *)

(* Prop7 pour un message marchand *)
(* Soit tbdd une bdd obtenue après traitement d'une liste de messages lmess et mm1 et mm2 deux prix tels que mm2<mm1.
   Soit lmess une liste de messages contenant (Pay tid mm2) et ne contenant pas (Pay tid mm1). Si l'on traite (Pay tid mm1) 
   sur tbdd, ça ne changera pas la ligne associée à tid dans la bdd *)

(* Prop 8 *)

(* Toute transaction validée ne peut être renégociée: si une transaction a
  été validée avec un montant {\tt am} celui-ci ne peut être changé.
*)

(* Lemme 42 *)
(* Dans une bdd si la ligne associée à un tid a un statut Validated, quelque soit le message (différent de Cancel) traité
   sur la bdd, les prix et le statut de la ligne ne change pas. *)


(* Définir Prop8 *)


(* Prop9: Le montant associé à une transaction validée correspond à un prix proposé
  par le client pour cette transaction. *)

(* Pas de lemmes intermédiaires *)


end

